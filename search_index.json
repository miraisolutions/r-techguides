[["index.html", "Technical Guidelines Introduction", " Technical Guidelines Mirai Solutions 2024-01-17 11:06:53.288005 Introduction Mirai Solutions is happy to share technical guidelines, how-tos and best practices in different areas. "],["roxygen-documentation-guidelines.html", "1 Roxygen documentation guidelines", " 1 Roxygen documentation guidelines The scope of this document is to provide opinionated yet motivated guidelines and best practices for documenting R objects (especially functions) with roxygen2. This is based on: roxygen2 vignettes: browseVignettes(\"roxygen2\"), in particular Generating Rd files. The tidyverse style guide. Package development experience. Examples are provided to show the concrete application of the described principles. "],["general-guidelines-and-documentation-workflow.html", "1.1 General guidelines and documentation workflow", " 1.1 General guidelines and documentation workflow Note that the ultimate goal of documentation is to have meaningful and consolidated help pages. For this reason, being happy about the roxygen tags in the source code is no enough, and the final help pages should always be checked as rendered by help(&lt;TOPIC&gt;). To quickly iterate trough documentation development, updates and checks, the following is recommended. Use devtools::check_man(), which does some basic checks on top of roxygenizing your package, hinting about e.g. undocumented arguments. Assess the development version of the documentation via pkgload::dev_help(&lt;TOPIC&gt;), which is quicker than re-building the whole package and using help(), allowing faster iterations. The final documentation should be then checked using R CMD check (possibly with packages devtools or rcmdcheck), and the help pages assessed with help(&lt;TOPIC&gt;) after installing the package. For larger documentation efforts, it can be worth to generate the full PDF manual, where it is easier to also cross-check consistency at the whole package level. An approach seen too often is to introduce roxygen documentation tags very early in the development of e.g. a function, using simple, pretty-uninformative placeholder tags. Early documentation is very useful if already thought-through upfront, to help thinking about and better design e.g. interfaces, usage, behavior, return values. Early, poor documentation tags only serve the purpose of a skeleton, but may give the wrong impression of an actual documentation effort. Instead, it can be a good idea to add normal comments describing the function behavior (even a single comment saying what the function does). This can be the basis of proper, thought-through documentation tags at a more advanced development stage. Also note that RStudio offers the creation of a roxygen skeleton (Code &gt; Insert Roxygen skeleton or Shift+Ctrl+Alt+), so there is little need / benefit in creating one manually, with poor content, ahead of time. "],["content-organization.html", "1.2 Content organization", " 1.2 Content organization Content structure and order of the roxygen2 documentation should be organized for readability, alignment with the rendered content, maintainability. Apart from the @title (see below), always use sentence case with a final period (.). Content order should reflect how sections appear in the resulting help page: title, description, arguments, details, value, custom sections, references, see also, examples. Note that @family belongs to the ‘See Also’ section, so place it accordingly. Place @inherit* and @template tags in the relevant place for the content you are including. Use an empty line to separate sections Avoid stating explicit @title and (single-paragraph) @description tags, they will be inferred by position. Put single-paragraph content right after the tag (@details Bla bla.). If you have multi-paragraph content for a single tag, separate the paragraphs with an empty line and start the first paragraph on a new line rather than right after the tag. Note that multi-paragraph description always requires an explicit @description. Place NAMESPACE-related tags @importFrom, @import, @export at the bottom and in this order. Use one @importFrom per symbol (not per package) and try to avoid @import. For un-exported objects documented for internal purposes, specify @keywords internal instead of @export. Use markdown: If not done at package level, @md should be the last element (so it can easily be removed when moving to package-level). Do not use @rdname if not documenting multiple objects (see below). Break lines at 80 characters of content (you can set Tools &gt; Global Options &gt; Code &gt; Display &gt; Margin column: 80 and &gt; Show margin for visual aid): No matter how wide your screen is, human brain is still not meant for processing long text, which would be poorly readable (code is a different story). Use RStudio menu Edit &gt; Reflow comment (Shift+Ctrl+/) after selecting a single block (selecting several parts might screw things up), which will also indent the lines after the first when needed. 1.2.1 Note about @title Keep in mind that the content of @title (the top paragraph, w/o explicit tag as recommended above) is used and displayed for two purposes in the R documentation: Title of the topics help page (the most know and natural usage). Brief description / hint to topics in the package help index (e.g. help(package = \"roxygen2\")), a less known and often forgotten usage. With this in mind: You may want to use title case (more natural for 1.) or sentence case (more sensible for 2.), but be consistent within a package (and never add a final period, ugly for 1.). Avoid using the very same topic name as title (e.g. the function name when documenting a function). This does not provide any extra information, especially in the help index, where describing e.g. myFunction as “myFunction” is pretty pointless. "],["advanced-usage-and-consistent-documentation.html", "1.3 Advanced usage and consistent documentation", " 1.3 Advanced usage and consistent documentation Several techniques and tools are available to enable and support a more consistent and maintainable documentation. This can be described in detail in the Do repeat yourself section of vignette Generating Rd files, and are summarized as follows Cross-link documentation files with @seealso and @family. Reuse parameter documentation with @inherit, @inheritParams, and @inheritSections. Document multiple functions in the same place with @describeIn or @rdname. Run arbitrary R code with @eval. Create reusable templates with @template and @templateVar. 1.3.1 Roxygen templates and example scripts Roxygen templates allow modularizing documentation content. Shared content sits in R files under the man-roxygen directory, and is included using the @template tag. Similarly, examples written as normal R code can be included in the ‘Examples’ section using @example (without s), which for long examples is way more convenient and less tedious than writing them as roxygen comments in the @examples section. The man-roxygen directory must be added to .Rbuildignore, e.g. via usethis::use_build_ignore(\"man-roxygen\") Template files should be called &lt;TAG&gt;-&lt;NAME&gt;.R depending on which @&lt;TAG&gt; they contain (typically one per template), and be included according to the corresponding tag order. This improves the readability and maintenance of template-based documentation e.g., param-first_arg.R contains #' @param first_arg Bla bla bla. Markdown must be specified via @md in each template if not defined at package level. Examples R scripts should be called ex-&lt;FUNCTION_NAME&gt;.R and placed in man-roxygen (for convenience). They are then included via @example man-roxygen/ex-&lt;FUNCTION_NAME&gt;.R. 1.3.2 Using @rdname and @describeIn Tags @rdname and @describeIn are a convenient way to document multiple functions in the same file. See the roxygen2 vignette Generating Rd files (vignette(\"rd\", package = \"roxygen2\")) for more detail. In both case, not that @title should be specified only for the main documentation object, since it will be ignored for others (a help page allowing only one title). It may also be convenient to collect the main generic documentation content as roxygen2 tags for a NULL object with an explicit @name (see examples below). Usage of @rdname @rdname provides the greatest flexibility for combining documentation (description, arguments, details, etc.) of several objects into a single documentation entry. Tag @rdname should the first tag, and should be used exclusively when appending documentation content for a new object to another existing @rdname. Having an @rdname for single and full-documented objects should be avoided since it is redundant and unnecessary; it gives the impression we want to document this object alongside others; it does not help if we later want to change the @rdname to a different topic, since the documentation content must be probably adapted (e.g. @title should be removed as it would be ignored). Usage of @describeIn @describeIn &lt;name&gt; &lt;description&gt; is meant for a set of functions with (almost) same arguments and that can be described in a general way in the ‘Description’ section, whereas individual &lt;description&gt;s are collected in a final section ‘Functions’. Tag @describeIn should be the last tag before the specific @examples and namespace tags (and possibly after specific @param). "],["examples.html", "1.4 Examples", " 1.4 Examples The following examples make use of the demo package roxygenExPkg. The package can be installed as: remotes::install_github( &quot;miraisolutions/techguides/roxygen-guidelines/roxygenExPkg&quot; ) The command help(package = \"roxygenExPkg\") will give you access to the package help. 1.4.1 General content organization See the corresponding ?roxygenExPkg::fun_doc. #&#39; Function Documentation Example #&#39; #&#39; Show an example of roxygen tags organization, providing documentation best #&#39; practices and guidelines. An explicit `@description` is only needed for #&#39; multi-paragraph descriptions. #&#39; #&#39; @param first_arg Description of the first argument. Also define data type / #&#39; class / structure / vectorization expectations where not obvious, and #&#39; possibly use (see &#39;Details&#39;). #&#39; @param second_arg Second argument of the function. #&#39; #&#39; @details More details or context about the function and its behaviour. List #&#39; possible side-effects, corner-cases and limitations here. Also use this #&#39; section for describing the meaning and usage of arguments when this is too #&#39; complex or verbose for the `@param` tags. #&#39; #&#39; @section Custom section: #&#39; The content of a custom section. #&#39; #&#39; @return Returns `NULL`, invisibly. The function is called for illustration #&#39; purposes only. #&#39; #&#39; @references #&#39; Hadley Wickham, Peter Danenberg and Manuel Eugster. roxygen2: In-Line #&#39; Documentation for R. [https://CRAN.R-project.org/package=roxygen2](). #&#39; #&#39; Hadley Wickham, The tidyverse style guide. #&#39; [https://style.tidyverse.org/documentation.html](). #&#39; #&#39; @seealso [fun_doc_tpl()], [roxygen2::roxygenize()]. Even if you just put #&#39; comma-separated links to functions, don&#39;t forget the final period (.). #&#39; @family function documentation examples #&#39; #&#39; @examples #&#39; # illustrate through examples how functions can be used #&#39; fun_doc(&quot;example_string&quot;, 3) #&#39; #&#39; @importFrom roxygen2 roxygenize #&#39; @importFrom roxygen2 roxygenise #&#39; @export #&#39; #&#39; @md fun_doc &lt;- function(first_arg, second_arg) { invisible() } 1.4.2 Templates and example scripts See the corresponding ?roxygenExPkg::fun_doc_tpl. #&#39; Template Documentation Example #&#39; #&#39; Show an example of roxygen tags organization, providing documentation best #&#39; practices and guidelines, using templates. #&#39; #&#39; @template param-first_arg #&#39; @param second_arg Description of the second argument. #&#39; #&#39; @template details-fun_doc #&#39; #&#39; @section Custom section: #&#39; The content of a custom section. #&#39; #&#39; @template return-NULL #&#39; #&#39; @template reference-roxygen2 #&#39; @template reference-tidyverse_style_guide #&#39; #&#39; @seealso [fun_doc_tpl()], [roxygen2::roxygenize()]. Even if you just put #&#39; comma-separated links to functions, don&#39;t forget the final period (.). #&#39; @family function documentation examples #&#39; #&#39; @example man-roxygen/ex-fun_doc_tpl.R #&#39; #&#39; @importFrom roxygen2 roxygenize #&#39; @importFrom roxygen2 roxygenise #&#39; @export #&#39; #&#39; @md fun_doc_tpl &lt;- function(first_arg, second_arg) { invisible() } 1.4.3 @rdname See the corresponding ?roxygenExPkg::divide. #&#39; Scalar Division #&#39; #&#39; Divide an object by a scalar. #&#39; #&#39; @param x The object to be divided #&#39; @param d Scalar to divide `x` by. #&#39; #&#39; @return The result of the scalar division of `x`. #&#39; #&#39; @examples #&#39; x &lt;- matrix(1:6, 3L) #&#39; #&#39; @name divide #&#39; #&#39; @md NULL #&#39; @rdname divide #&#39; #&#39; @details `divide_by()` performes generic division by `d`. #&#39; #&#39; @examples #&#39; divide_by(x, 1.5) #&#39; #&#39; @export #&#39; #&#39; @md divide_by &lt;- function(x, d) { x / d } #&#39; @rdname divide #&#39; #&#39; @details `divide_by2()` performes division by two. #&#39; #&#39; @examples #&#39; divide_by2(x) #&#39; #&#39; @export #&#39; #&#39; @md divide_by2 &lt;- function(x) { divide_by(x, 2) } #&#39; @rdname divide #&#39; #&#39; @details `divide_by3()` performes division by three. #&#39; #&#39; @examples #&#39; divide_by3(x) #&#39; #&#39; @export #&#39; #&#39; @md divide_by3 &lt;- function(x) { divide_by(x, 3) } #&#39; @rdname divide #&#39; #&#39; @details `divide_by4()` performes division by four. #&#39; #&#39; @examples #&#39; divide_by4(x) #&#39; #&#39; @export #&#39; #&#39; @md divide_by4 &lt;- function(x) { divide_by(x, 4) } 1.4.4 @describeIn See the corresponding ?roxygenExPkg::times. #&#39; Scalar Multiplication #&#39; #&#39; Multiply an object by a scalar. #&#39; #&#39; @param x The object to be multiplied. #&#39; @param m Scalar to multiply `x` by. #&#39; #&#39; @return The result of the scalar multiplication of `x`. #&#39; #&#39; @describeIn times Generic multiplication by `m`. #&#39; #&#39; @examples #&#39; x &lt;- matrix(1:6, 3L) #&#39; #&#39; times(x, 1.5) #&#39; #&#39; @export #&#39; #&#39; @md times &lt;- function(x, m) { x * m } #&#39; @describeIn times Multiplication by 2. #&#39; #&#39; @examples #&#39; times2(x) #&#39; #&#39; @export #&#39; #&#39; @md times2 &lt;- function(x) { times(x, 2) } #&#39; @describeIn times Multiplication by 3. #&#39; #&#39; @examples #&#39; times3(x) #&#39; #&#39; @export #&#39; #&#39; @md times3 &lt;- function(x) { times(x, 3) } #&#39; @describeIn times Multiplication by 4. #&#39; #&#39; @examples #&#39; times4(x) #&#39; #&#39; @export #&#39; #&#39; @md times4 &lt;- function(x) { times(x, 4) } "],["version-stable-r-development-with-docker.html", "2 Version-stable R development with Docker", " 2 Version-stable R development with Docker In the context of productive solutions, it is essential to have full control over the code-base and environment to ensure reproducibility and stability of the setup. In the case of R-based projects, this implies fixing and aligning the version of R as well as package and system dependencies. In order to achieve well-managed release pipelines, a key aspect is to guarantee full equivalence of the development setup to (alternative) target productive stages. This guide illustrates an approach to manage a version-stable R development environment based on containerized solutions leveraging the Rocker project, allowing the coexistence of multiple dockerized development flavors, to match various target production environments or projects. "],["version-stable-deployments.html", "2.1 Version-stable deployments", " 2.1 Version-stable deployments When deploying R applications (e.g. a Shiny app) using Docker containers, it is important to control versioning of R and packages for the sake of reproducibilty and stability of the deployments. For this reason, version-stable images are provided as part of the Rocker project and used as a basis for deploying productive applications. Each version-stable Rocker image has an associated tag for all non-latest R versions (e.g. rocker/r-ver:3.6.1). Besides being specific to the corresponding version of R, each tag fixes the version of contributed packages (by using as package repository the MRAN snapshot of the last day CRAN distributed that R version as latest release). See VERSIONS.md The Dockerfile of a deployed application then defines a given version-stable image tag to start FROM, e.g. FROM rocker/r-ver:3.6.1 See SmaRP/Dockerfile for an example. "],["align-local-development-and-deployment-environments.html", "2.2 Align local development and deployment environments", " 2.2 Align local development and deployment environments When developing and testing an app locally, it is important to ensure the environment is aligned with the target deployment environment. This might imply using e.g. multiple R and package versions for the local development of different applications, which clash with the typical setup (especially on Linux systems), where only one R version (the latest release) exists. The idea is then to rely on the same version-stable rocker containers used for the deployments, using a containerized versioned RStudio instance for the local development. This is available through Rocker’s versioned stack, so we could use e.g. rocker/rstudio:3.6.1. Note that the same version-stable instance of RStudio can be used across all different projects for which such version is relevant. For this reason, a sensible choice is to rely on rocker/verse, which adds tidyverse and devtools to the stack, as well as properly setting up R Markdown system dependencies TinyTeX and pandoc, sparing the effort of the tedious extra install. See the specific section below about ‘TinyTeX considerations’. 2.2.1 Running versioned RStudio instances Assume we want to run a containerized versioned instance of RStudio for R 3.6.1, possibly alongside instances for other versions of R. First of all, we need to get the image from docker-hub docker pull rocker/verse:3.6.1 We then want to have a running instance on localhost (127.0.0.1), with the following setup: No authentication required (local setup). Enable root by setting the environment variable ROOT to TRUE, so that e.g. sudo apt-get can be used in RStudio. Use a version-specific port, e.g. 3500 for R 3.5.0, 3610 for R 3.6.1 and so on, so that we can use localhost for concurrent R version instances. The development code of all relevant projects should live outside the container and be shared with it (and possibly many of them), e.g. under ~/RStudioProjects on the host machine and /home/rstudio/RStudioProjects in the container. For this to work w/o permission issues, the container user (rstudio) must match the UID of the host user ($UID). In order for the RStudio setting to persist if the container is recreated (e.g. after pulling a new rocker image), we also use a shared volume (like ~/.rstudio-docker/3.6.1) for the home/rstudio/.rstudio directory, which is version-specific in case of multiple R versions If we want to use Meld via the compareWith addins, we need to map the DISPLAY environment variable and volume /tmp/.X11-unix add DISPLAY to Renviron install Meld install dbus-x11 Use a version-specific name for the container running the RStudio instance, e.g. rstudio_3.6.1. R_VER=3.6.1 SHARED_DIR=RStudioProjects docker run -d --restart=always \\ -p 127.0.0.1:$(echo $R_VER | sed &#39;s/[.]//g&#39;)0:8787 \\ -e DISABLE_AUTH=true \\ -e ROOT=TRUE \\ -e USERID=$UID \\ -v $HOME/$SHARED_DIR:/home/rstudio/$SHARED_DIR \\ -v $HOME/.rstudio-docker/$R_VER:/home/rstudio/.rstudio \\ -e DISPLAY=$DISPLAY \\ -v /tmp/.X11-unix:/tmp/.X11-unix:ro \\ --name rstudio_$R_VER \\ rocker/verse:$R_VER # R and RStudio are not getting the DISPLAY environment variable docker exec rstudio_$R_VER bash -c \\ &#39;echo &quot;DISPLAY=${DISPLAY}&quot; &gt;&gt; /usr/local/lib/R/etc/Renviron&#39; # Install Meld docker exec rstudio_$R_VER bash -c \\ &#39;apt-get update &amp;&amp; apt-get install -y --no-install-recommends meld dbus-x11&#39; The running RStudio can then be accessed by visiting http://localhost:3610/. You may find convenient to define a shell function as follows run_rstudio_ver() { local R_VER=${1:?&quot;you must supply the R version as first argument&quot;} local SHARED_DIR=${2:?&quot;you must supply the shared directory as second argument&quot;} local RVER_IMAGE=${3:-&quot;verse&quot;} local BASE_IMAGE=rocker/$RVER_IMAGE:$R_VER local PORT=$(echo $R_VER | sed &#39;s/[.]//g&#39;)0 local CONTANER_NAME=rstudio_$R_VER echo &quot;Containerized version-stable RStudio for R &quot;$R_VER\\ &quot;based on image &quot;$BASE_IMAGE\\ &quot;with shared volume &quot;$SHARED_DIR docker pull $BASE_IMAGE &amp;&amp; docker run -d --restart=always \\ -p 127.0.0.1:$PORT:8787 \\ -e DISABLE_AUTH=true \\ -e ROOT=TRUE \\ -e USERID=$UID \\ -v $HOME/$SHARED_DIR:/home/rstudio/$SHARED_DIR \\ -v $HOME/.rstudio-docker/$R_VER:/home/rstudio/.rstudio \\ -e DISPLAY=$DISPLAY \\ -v /tmp/.X11-unix:/tmp/.X11-unix:ro \\ --name $CONTANER_NAME \\ $BASE_IMAGE &amp;&amp; # R and RStudio are not getting the DISPLAY environment variable docker exec $CONTANER_NAME bash -c \\ &#39;echo &quot;DISPLAY=${DISPLAY}&quot; &gt;&gt; /usr/local/lib/R/etc/Renviron&#39; &amp;&amp; # Install Meld docker exec $CONTANER_NAME bash -c \\ &#39;apt-get update &amp;&amp; apt-get install -y --no-install-recommends meld dbus-x11&#39; &amp;&amp; echo &quot;RStudio running in container &quot;$CONTANER_NAME&quot; on port &quot;$PORT &amp;&amp; echo &quot;visit http://localhost:&quot;$PORT } which you can re-use as compact command for any R version as follows run_rstudio_ver 3.6.1 RStudioProjects Note that --restart=always specifies that the container should stay up and restart itself after stopping, e.g. upon machine reboot or docker upgrade, so that it is always available. Still, you can explicitly stop the running container with docker stop rstudio_3.6.1 Alternatively, you can omit --restart=always and explicitly start the container whenever needed with docker start rstudio_3.6.1 Note that start/stop operations do not affect the persistence of files created outside the shared location, including global RStudio options such as dark theme, diagnostic, etc. (set via Tools &gt; Global Options…). On the other hand, these files and settings do not (see above) persist removing the container (docker rm, see below) . 2.2.2 TinyTeX considerations 2.2.2.1 pdfcrop Older rocker/verse images might not include pdfcrop, which is required for the default and desirable cropping of PDF figures with R Markdown (see rocker-org/rocker-versioned#146). Make sure pdfcrop is installed by running at R console tinytex::tlmgr_install(&quot;pdfcrop&quot;) (see R Markdown: The Definitive Guide) 2.2.2.2 Align TinyTeX to current remote repo NOTE - This should never be needed with recent rocker/verse images, where a version-stable Tex Live repository is used for the TinyTeX install (see rocker-org/rocker-versioned#169). If you are using LaTeX and start seeing errors like Remote repository is newer than local (2018 &lt; 2019) it means that you have to re-install TinyTeX. This happens e.g. with rocker/verse:3.6.1, since it was build at the end of 2018 but the current Tex Live repo is 2019. You can fix this via a user-specific re-installation of TinyTeX for R. NOTE however that this will uninstall the system-level TinyTeX pre-installed in rocker/verse. First, make sure /home/rstudio/bin is part of the PATH environment variable. Check this by running docker exec --user rstudio rstudio_3.6.1 R --slave -e &#39;Sys.getenv(&quot;PATH&quot;)&#39; If you don’t see /home/rstudio/bin, you can make sure it is part of the PATH for R via docker exec --user rstudio rstudio_3.6.1 sh -c &#39;echo &quot;PATH=$HOME/bin:\\${PATH}&quot; &gt;&gt; $HOME/.Renviron&#39; # check again docker exec --user rstudio rstudio_3.6.1 R --slave -e &#39;Sys.getenv(&quot;PATH&quot;)&#39; Then, from the running RStudio, run tinytex::reinstall_tinytex() 2.2.3 Cleanup docker rm $(docker stop rstudio_3.6.1) "],["references.html", "2.3 References", " 2.3 References The Rocker Project Shared Volumes Rocker Wiki Sharing files with host machine "],["control-dependencies-with-renv.html", "3 Control dependencies with renv", " 3 Control dependencies with renv For production readiness - and project safety - it is important to control the dependencies of a piece of development. This can be done at project level using the package renv. In a renv-project (and a new R session starts), renv detects the project dependencies and whether they are out of sync, ensuring the same virtual environment applies all the time the project is opened. This approach ensures that the set of dependencies is collaboratively shared and maintained. Moreover, it can be used to align the development environment to the production stage. Managing the dependencies the way up to production improves reproducibility, a key requirement in enterprise. Finally, as the control is at project level, it is possible to have different virtual environments (for example different packages version) for different projects, while keeping the maintenance of the versioned package library efficient through caching. "],["install-renv.html", "3.1 Install renv", " 3.1 Install renv renv can be installed from CRAN as: install.packages(&quot;renv&quot;) "],["initialize-an-renv-project.html", "3.2 Initialize an renv project", " 3.2 Initialize an renv project To initialize a package with renv, run: renv::init( # use the DESCRIPTION file to capture dependencies settings = list(snapshot.type = &quot;explicit&quot;), # do not install dependencies (done in a custom way) bare = TRUE ) This ensures that the dependencies of the package, as listed in the DESCRIPTION file are used for initializing the virtual environment. Note: renv tracks and installs only the packages explicitly mentioned in the DESCRIPTION file. This means that only the dependencies used by the package are installed. Packages needed for development, such as devtools, should be be installed for the specific project via install.packages() or renv::install(). The renv initialization causes: the creation of a new renv.lock file where the R version and the list of used packages with their version are tracked; the creation of a new renv folder containing: a setting file settings.dcf, a script activate.R to activate the project-specific virtual environment, the project-specific library of installed packages; the execution of the activation script on project launch via .Rprofile; an update of the .Rbuildignore because the renv-specific files are not part of the R package infrastructure; an update of the .gitignore to exclude the renv library from version control, as it can be simply restored via renv::restore(). Having all the renv infrastructure committed under version control ensures that the same renv setup is available to anyone working on the same project (via renv::restore()). 3.2.1 Control packages version As a note, if the DESCRIPTION file does not request a specific package version, the renv initialization will pick the version currently available in the user library when the snapshot of the packages was created. However, it is advisable to have a stricter control over the version of the packages used in a project. To do so, one can set the option to install dependencies from a specific MRAN repo, therefore fixing the version for all available packages. # Install all dependencies from a specific MRAN date repo options(repos = &quot;https://mran.microsoft.com/snapshot/2020-11-15&quot;) One can then install the dependencies of a package via: renv::install(&quot;remotes&quot;) (deps &lt;- remotes::dev_package_deps(dependencies = TRUE)) renv::install(with(deps, sprintf(&quot;%s@%s&quot;, package[diff!=0], available[diff!=0]))) To create a snapshot of the package dependencies and update the renv.lock file: # Create a snapshot to track dependencies in the lockfile renv::snapshot() "],["caching-the-packages-versions.html", "3.3 Caching the packages’ versions", " 3.3 Caching the packages’ versions renv caches the packages’ versions. If you have installed the same package version in a different project, you should have it already cached and available. By running: renv::status() One can check if packages versions are out of sync and via renv::restore() It is possible to restore the versions as listed in the renv.lock file. "],["removing-the-renv-setup-from-a-project.html", "3.4 Removing the renv setup from a project", " 3.4 Removing the renv setup from a project If you would like to remove the renv setup from a project: run renv::deactivate() to fall back on a renv-free setup; delete renv.lock and the renv folder for clarity. "],["cicd-pipelines-for-automatic-deployment-of-a-r-shiny-web-app.html", "4 CI/CD pipelines for automatic deployment of a R Shiny web app", " 4 CI/CD pipelines for automatic deployment of a R Shiny web app It is good practice to integrate and develop an R Shiny app as an R package, to take full advantage of all the integrated features established for R packages (e.g., documentation, package namespaces, automated testing, R CMD check, etc.). A typical development workflow to package a Shiny app is provided by the golem package. Later in this chapter we will also indicate how to package a shiny app without the infrastructure provided by golem. Furthermore, version control systems such as Git are a great asset for keeping track an manage changes, especially in a collaborative setup. The development of a packaged Shiny app under version control can easily enable and take advantage of: Continuous Integration (CI) pipelines to automate checks and ensure higher code quality and robustness; Continuous Deployment (CD) pipelines to automate the process of deployment to a productive environment. This guide illustrates how to set up CI/CD pipelines with a focus on the increasingly popular GitHub Actions, which we recommend as a natural choice for GitHub open source projects. In particular, it shows how a Shiny app developed as an R package can be maintained on a GitHub repository, be deployed to and hosted on shinyapps.io using said CI/CD pipelines. For the sake of completeness, and for historical reasons, the guide also covers the CI/CD setup on Travis CI, a well established service that has become not attractive any longer for open source projects due to its change of policy in recent years. ShinyCICD is a minimal example of a packaged Shiny app that will be used as an example throughout the guide. You can simply fork the repository and setup your specific user settings (especially for shinyapps.io) to see CI/CD pipelines in actions, or follow the steps described below to setup CI/CD pipelines for your own app. "],["generic-cicd-pipeline.html", "4.1 Generic CI/CD pipeline", " 4.1 Generic CI/CD pipeline Generally speaking, a CI/CD pipeline related to an R package is comprised of the following steps: setup a running environment setup R check out the package source code install system dependencies install package dependencies (with caching) build the package check the package deploy GitHub Actions provides great flexibility in specifying and customizing each individual step, but many are covered by the R-specific actions provided by the r-lib/actions project. Most of these steps are implemented by default in Travis CI for an R package. "],["github-actions.html", "4.2 GitHub Actions", " 4.2 GitHub Actions GitHub Actions is a service for running highly-customizable and flexible automated workflows, fully integrated with GitHub and very suitable to CI/CD pipelines. Workflows use YAML syntax and should be stored in the .github/workflows directory in the root of the repository. Workflows are constituted of jobs and each job is a set of steps to perform individual tasks, e.g. commands or actions. The next sections describe in detail the relevant workflow steps of a typical CI/CD pipeline for a packages Shiny app, also covering the usage of renv to track package dependencies. Finally, we will show how you can use the convenience function usethis::use_github_action() for including such workflows in you project. 4.2.1 Workflow steps A workflow should have an identifying name and an on section that indicates upon which events the workflow should be triggered. It should include at least one job and each job will have a set of steps fully specifying what to execute. Such steps can be an action (predefined, sourcing from GitHub repos that contain such actions) or custom shell commands. With the introduction of composite Actions, most of the relevant workflow steps for an R project are covered by actions provided by the r-lib/actions. 4.2.1.1 Setup Checkout the source package from the repository, using actions/checkout provided by GitHub. Setup R using the action r-lib/actions/setup-r. Install package dependencies (including system requirements and caching) using r-lib/actions/setup-r-dependencies. Using renv If your project relies on package renv for tracking dependencies via an renv.lock file, caching and installation of R package dependencies requires a different setup, as described in the Using renv with Continuous Integration vignette. As shown in the complete workflow files below: system requirements are installed explicitly (for the ubuntu runner defined for the workflow) based on remotes::system_requirements() dependencies tracked by renv are installed (including caching) using r-lib/actions/setup-renv 4.2.1.2 Package check Check the package via rcmdcheck::rcmdcheck(). 4.2.1.3 Deployment Continuous deployment to shinyapps.io is automated upon any push to the master branch In order to provide credentials for the deployment, account name and corresponding tokens for shinyapps.io are defined as environment variables SHINYAPPS_ACCOUNT, SHINYAPPS_TOKEN and SHINYAPPS_SECRET, specified / accessible as GitHub secrets. A convenience R script, e.g. deploy/deploy-shinyapps.R (build-ignored via usethis::use_build_ignore(\"deploy\")), defines the deployment commands based on the environment variables. # deploy/deploy-shinyapps.R # usethis::use_build_ignore(&quot;deploy&quot;) rsconnect::setAccountInfo( Sys.getenv(&quot;SHINYAPPS_ACCOUNT&quot;), Sys.getenv(&quot;SHINYAPPS_TOKEN&quot;), Sys.getenv(&quot;SHINYAPPS_SECRET&quot;) ) rsconnect::deployApp(appName = &quot;ShinyCICD&quot;) 4.2.2 Workflow file The steps described in the previous section are defined in the .yml workflow file as follows: # Workflow derived from https://github.com/r-lib/actions/tree/v2/examples # Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help # Name of the workflow =&gt; usethis::use_github_actions_badge(&quot;CI-CD&quot;) name: CI-CD on: # Triggered on push and pull request events push: pull_request: # Allow manual runs from the Actions tab workflow_dispatch: jobs: CI-CD: runs-on: ${{ matrix.config.os }} name: ${{ matrix.config.os }} (${{ matrix.config.r }}) strategy: # We keep a matrix for convenience, but we would typically just run on one # single OS and R version, aligned with the target deployment environment matrix: config: - {os: ubuntu-latest, r: &#39;release&#39;} env: # Access token for GitHub GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }} # Preserve package sources for informative references in case of errors R_KEEP_PKG_SOURCE: yes steps: - name: Checkout repo uses: actions/checkout@v3 - name: Setup R uses: r-lib/actions/setup-r@v2 with: r-version: ${{ matrix.config.r }} # Enable RStudio Package Manager to speed up package installation use-public-rspm: true - name: Install and cache dependencies uses: r-lib/actions/setup-r-dependencies@v2 with: extra-packages: any::rcmdcheck - name: Check package uses: r-lib/actions/check-r-package@v2 - name: Deploy to shinyapps.io # Continuous deployment only for pushes to the main / master branch if: github.ref == &#39;refs/heads/main&#39; || github.ref == &#39;refs/heads/master&#39; env: SHINYAPPS_ACCOUNT: ${{ secrets.SHINYAPPS_ACCOUNT }} SHINYAPPS_TOKEN: ${{ secrets.SHINYAPPS_TOKEN }} SHINYAPPS_SECRET: ${{ secrets.SHINYAPPS_SECRET }} run: Rscript deploy/deploy-shinyapps.R As visible from the run logs that can be found in the GitHub repository under the Actions tab, all the CI/CD pipeline steps are performed subsequently, and are identifiable by the name field. See the example below, showing how the deployment step is skipped for a run not triggered by a push action the main (or master) branch: 4.2.3 Complete workflows and usethis::use_github_action() Full YAML workflows for CI and CI/CD pipelines, with and without renv, are shown below and provided as part of this guide. In order to setup and use CI/CD GitHub Actions workflows as described above, you can simply include the relevant workflow file your project via: usethis::use_github_action(url = paste0( &quot;https://github.com/miraisolutions/techguides/blob/master/&quot;, &quot;shiny-ci-cd/actions/ci-cd.yml&quot; # &quot;shiny-ci-cd/actions/ci-cd-renv.yml&quot; # &quot;shiny-ci-cd/actions/ci.yml&quot; # &quot;shiny-ci-cd/actions/ci-renv.yml&quot; )) usethis::use_github_actions_badge(&quot;CI-CD&quot;) # or &quot;CI&quot; 4.2.3.1 Complete workflow files shiny-ci-cd/actions/ci-cd.yml # Workflow derived from https://github.com/r-lib/actions/tree/v2/examples # Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help # Name of the workflow =&gt; usethis::use_github_actions_badge(&quot;CI-CD&quot;) name: CI-CD on: # Triggered on push and pull request events push: pull_request: # Allow manual runs from the Actions tab workflow_dispatch: jobs: CI-CD: runs-on: ${{ matrix.config.os }} name: ${{ matrix.config.os }} (${{ matrix.config.r }}) strategy: # We keep a matrix for convenience, but we would typically just run on one # single OS and R version, aligned with the target deployment environment matrix: config: - {os: ubuntu-latest, r: &#39;release&#39;} env: # Access token for GitHub GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }} # Preserve package sources for informative references in case of errors R_KEEP_PKG_SOURCE: yes steps: - name: Checkout repo uses: actions/checkout@v3 - name: Setup R uses: r-lib/actions/setup-r@v2 with: r-version: ${{ matrix.config.r }} # Enable RStudio Package Manager to speed up package installation use-public-rspm: true - name: Install and cache dependencies uses: r-lib/actions/setup-r-dependencies@v2 with: extra-packages: any::rcmdcheck - name: Check package uses: r-lib/actions/check-r-package@v2 - name: Deploy to shinyapps.io # Continuous deployment only for pushes to the main / master branch if: github.ref == &#39;refs/heads/main&#39; || github.ref == &#39;refs/heads/master&#39; env: SHINYAPPS_ACCOUNT: ${{ secrets.SHINYAPPS_ACCOUNT }} SHINYAPPS_TOKEN: ${{ secrets.SHINYAPPS_TOKEN }} SHINYAPPS_SECRET: ${{ secrets.SHINYAPPS_SECRET }} run: Rscript deploy/deploy-shinyapps.R shiny-ci-cd/actions/ci-cd-renv.yml # Workflow derived from https://github.com/r-lib/actions/tree/v2/examples # Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help # Name of the workflow =&gt; usethis::use_github_actions_badge(&quot;CI-CD-renv&quot;) name: CI-CD-renv on: # Triggered on push and pull request events push: pull_request: # Allow manual runs from the Actions tab workflow_dispatch: jobs: CI-CD: runs-on: ${{ matrix.config.os }} name: ${{ matrix.config.os }} (${{ matrix.config.r }}) strategy: # We keep a matrix for convenience, but we would typically just run on one # single OS and R version, aligned with the target deployment environment matrix: config: - {os: ubuntu-latest, r: &#39;release&#39;} env: # Access token for GitHub GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }} # Preserve package sources for informative references in case of errors R_KEEP_PKG_SOURCE: yes steps: - name: Checkout repo uses: actions/checkout@v3 - name: Setup R uses: r-lib/actions/setup-r@v2 with: r-version: ${{ matrix.config.r }} # Enable RStudio Package Manager to speed up package installation use-public-rspm: true - name: Install system dependencies # This is not taken care of (yet) by r-lib/actions/setup-renv # Package distro used to get the distro for the used ubuntu-latest run: | Rscript -e &quot;install.packages(c(&#39;remotes&#39;, &#39;distro&#39;))&quot; while read -r cmd do eval sudo $cmd done &lt; &lt;(Rscript -e &#39;writeLines(with(distro::distro(), remotes::system_requirements(id, short_version)))&#39;) - name: Activate renv and restore packages with cache uses: r-lib/actions/setup-renv@v2 - name: Install R CMD check run: install.packages(&quot;rcmdcheck&quot;) shell: Rscript {0} - name: Check package uses: r-lib/actions/check-r-package@v2 - name: Deploy to shinyapps.io # Continuous deployment only for pushes to the main / master branch if: github.ref == &#39;refs/heads/main&#39; || github.ref == &#39;refs/heads/master&#39; env: SHINYAPPS_ACCOUNT: ${{ secrets.SHINYAPPS_ACCOUNT }} SHINYAPPS_TOKEN: ${{ secrets.SHINYAPPS_TOKEN }} SHINYAPPS_SECRET: ${{ secrets.SHINYAPPS_SECRET }} run: Rscript deploy/deploy-shinyapps.R shiny-ci-cd/actions/ci.yml # Workflow derived from https://github.com/r-lib/actions/tree/v2/examples # Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help # Name of the workflow =&gt; usethis::use_github_actions_badge(&quot;CI&quot;) name: CI on: # Triggered on push and pull request events push: pull_request: # Allow manual runs from the Actions tab workflow_dispatch: jobs: CI-CD: runs-on: ${{ matrix.config.os }} name: ${{ matrix.config.os }} (${{ matrix.config.r }}) strategy: # We keep a matrix for convenience, but we would typically just run on one # single OS and R version, aligned with the target deployment environment matrix: config: - {os: ubuntu-latest, r: &#39;release&#39;} env: # Access token for GitHub GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }} # Preserve package sources for informative references in case of errors R_KEEP_PKG_SOURCE: yes steps: - name: Checkout repo uses: actions/checkout@v3 - name: Setup R uses: r-lib/actions/setup-r@v2 with: r-version: ${{ matrix.config.r }} # Enable RStudio Package Manager to speed up package installation use-public-rspm: true - name: Install and cache dependencies uses: r-lib/actions/setup-r-dependencies@v2 with: extra-packages: any::rcmdcheck - name: Check package uses: r-lib/actions/check-r-package@v2 shiny-ci-cd/actions/ci-renv.yml # Workflow derived from https://github.com/r-lib/actions/tree/v2/examples # Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help # Name of the workflow =&gt; usethis::use_github_actions_badge(&quot;CI-renv&quot;) name: CI-renv on: # Triggered on push and pull request events push: pull_request: # Allow manual runs from the Actions tab workflow_dispatch: jobs: CI-CD: runs-on: ${{ matrix.config.os }} name: ${{ matrix.config.os }} (${{ matrix.config.r }}) strategy: # We keep a matrix for convenience, but we would typically just run on one # single OS and R version, aligned with the target deployment environment matrix: config: - {os: ubuntu-latest, r: &#39;release&#39;} env: # Access token for GitHub GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }} # Preserve package sources for informative references in case of errors R_KEEP_PKG_SOURCE: yes steps: - name: Checkout repo uses: actions/checkout@v3 - name: Setup R uses: r-lib/actions/setup-r@v2 with: r-version: ${{ matrix.config.r }} # Enable RStudio Package Manager to speed up package installation use-public-rspm: true - name: Install system dependencies # This is not taken care of (yet) by r-lib/actions/setup-renv # Package distro used to get the distro for the used ubuntu-latest run: | Rscript -e &quot;install.packages(c(&#39;remotes&#39;, &#39;distro&#39;))&quot; while read -r cmd do eval sudo $cmd done &lt; &lt;(Rscript -e &#39;writeLines(with(distro::distro(), remotes::system_requirements(id, short_version)))&#39;) - name: Activate renv and restore packages with cache uses: r-lib/actions/setup-renv@v2 - name: Install R CMD check run: install.packages(&quot;rcmdcheck&quot;) shell: Rscript {0} - name: Check package uses: r-lib/actions/check-r-package@v2 "],["travis-ci.html", "4.3 Travis CI", " 4.3 Travis CI Travis CI is a continuous integration service that can be used to build and test software projects hosted on GitHub. To set up Travis CI you need to login at travis-ci.com (using your GitHub account) and provide authorization via GitHub (see Travis CI Tutorial). Travis CI used to be a very established, mature and popular tool in the open-source source community, before a recent change of policy made it less focused on open-source, offering only limited free trial plans. 4.3.1 Standard CI setup To setup Travis CI in a project use: usethis::use_travis() # use ext = &quot;com&quot; if usethis &lt; 1.6.0 This will generate a generic .travis.yml file # R for travis: see documentation at https://docs.travis-ci.com/user/languages/r language: R cache: packages As default, Travis CI takes care of package dependency installation and performs the typical package build &amp; check you would run locally via e.g. devtools::check(). Such a CI pipeline is triggered by any push event on any branch on the GitHub repo, including pull requests. 4.3.2 Using renv for your project If your project relies on the package renv for tracking dependencies via an renv.lock file, you should override the default installation package dependencies and make sure cacheing is adjusted accordingly, as described in the Using renv with Continuous Integration vignette: cache: directories: - $HOME/.local/share/renv - $TRAVIS_BUILD_DIR/renv/library install: - Rscript -e &quot;if (!requireNamespace(&#39;renv&#39;, quietly = TRUE)) install.packages(&#39;renv&#39;)&quot; - Rscript -e &quot;renv::restore()&quot; 4.3.3 Automated deployment Travis CI can be setup to perform a deployment (e.g. publish a shiny app on shinyapps.io) upon any push to the master branch, provided the CI checks pass. This is achieved for a shinyapps.io deployment by specifying in .travis.yml an additional deploy: section as deploy: provider: script skip_cleanup: true # strictly necessary only for the renv case script: - &gt;- Rscript -e &#39;account_info &lt;- lapply(paste0(&quot;SHINYAPPS_&quot;, c(&quot;ACCOUNT&quot;, &quot;TOKEN&quot;, &quot;SECRET&quot;)), Sys.getenv)&#39; -e &#39;do.call(rsconnect::setAccountInfo, account_info)&#39; -e &#39;rsconnect::deployApp(appName = &quot;ShinyCICD&quot;)&#39; on: branch: master where SHINYAPPS_ACCOUNT, SHINYAPPS_TOKEN, SHINYAPPS_SECRET are secure variables defined on Travis CI holding your account name and corresponding tokens for shinyapps.io. It is in fact more convenient to write an R script, saved as e.g. deploy/deploy-shinyapps.R (build-ignored via usethis::use_build_ignore(\"deploy\")) defining the deployment commands: # deploy/deploy-shinyapps.R # usethis::use_build_ignore(&quot;deploy&quot;) rsconnect::setAccountInfo( Sys.getenv(&quot;SHINYAPPS_ACCOUNT&quot;), Sys.getenv(&quot;SHINYAPPS_TOKEN&quot;), Sys.getenv(&quot;SHINYAPPS_SECRET&quot;) ) rsconnect::deployApp(appName = &quot;ShinyCICD&quot;) and then simply execute it as deploy script: deploy: provider: script skip_cleanup: true # strictly necessary only for the renv case script: Rscript deploy/deploy-shinyapps.R on: branch: master 4.3.4 Putting it all together The final .travis.yml file (for the non-renv case) would look like # R for travis: see documentation at https://docs.travis-ci.com/user/languages/r language: R cache: packages deploy: provider: script script: Rscript deploy/deploy-shinyapps.R on: branch: master As visible from the run logs, all the CI/CD pipeline steps are performed, despite only the deployment step being explicitly defined. "],["deploying-a-packaged-shiny-application.html", "4.4 Deploying a packaged shiny application", " 4.4 Deploying a packaged shiny application It makes sense to structure shiny applications as a package to better control their dependencies. However, some structural conditions are required for the deployment of a packaged shiny application. As already mentioned, one option is to use the golem package, which will initialize the shiny application with its framework that does support deployment of a shiny application as a package. But sometimes you may not want to add an entire framework to an existing application and instead add this support manually. Since we did not find any good documentation of this online (as of Nov 2020), we investigated this ourselves and are happy to share our findings here. 4.4.1 Entry point The application needs an entry point which should be named app.R and be situated in the root of the package, i.e. where DESCRIPTION and NAMESPACE are located. It should contain only what is required for the entry point to be able to load the application, e.g.: pkgload::load_all(export_all = FALSE, helpers = FALSE, attach_testthat = FALSE) # PKG is the name of the packaged shiny application # run_PKG_app is a function that wraps around shiny::shinyApp() PKG::run_PKG_app() run_PKG_app &lt;- function() { shinyApp(ui = ui, server = server) } # where ui and server are both functions 4.4.2 server and ui Both server and ui need to be functions in order to work in the packaged shiny application context. server should already be a function and it is enough to wrap ui into a function without any arguments or return statements. In the beginning of the ui function, we also need to add a call to shiny::addResourcePath to make static resources available. 4.4.3 non-CRAN dependencies Deploying a packaged shiny application which uses non-CRAN package sources like Github requires additional information in the DESCRIPTION file. Namely, the repository details of such dependencies must be included in a Remotes: field, so that tools like renv or remotes know where the packages should be retrieved from. "],["xlconnect-easy-and-controlled-interface-to-microsoft-excel.html", "5 XLConnect: easy and controlled interface to Microsoft Excel", " 5 XLConnect: easy and controlled interface to Microsoft Excel MS Excel is probably the most used support to share data analysis and reports in enterprise. Despite its popularity, performing data analysis within an Excel workbook can be cumbersome as well as error prone due to irreproducibility. A possible way out is to perform most of the steps of your data analysis and reporting in another programming language, such as R, and just present and share the results in Excel. Using the package XLConnect will allow you to read, write and manipulate MS Excel files from within R. XLConnect’s main features: read &amp; write Excel worksheets &amp; named regions create, remove, rename, clone &amp; hide / unhide worksheets add graphs specify / apply cell styles, column width &amp; row height define behavior when error cells are encountered force formula recalculation when workbooks are opened others: merge / unmerge cells, set auto-filters etc. "],["installation.html", "5.1 Installation", " 5.1 Installation XLConnect is cross-platform and runs in all operating systems that support Java. Besides R and a JRE (Java Runtime Environment), nothing else is needed, even an installation of MS Excel is NOT required. # Install XLConnect if (!require(XLConnect)) install.packages(&quot;XLConnect&quot;) # Load the XLConnect package and get ready to use it require(XLConnect) "],["basic-functions-write-read-an-excel-sheet.html", "5.2 Basic functions: write &amp; read an Excel sheet", " 5.2 Basic functions: write &amp; read an Excel sheet 5.2.1 Writing Excel files # Load Excel workbook - either .xls or .xlsx. Create if not existing wb &lt;- loadWorkbook(&quot;xlconnect-demo/XLConnectDemo.xlsx&quot;, create = TRUE) # Create a Sheet within an Excel workbook createSheet(wb, name = &quot;CHF&quot;) # Write into a sheet # Write Swiss Francs data frame into CHF sheet writeWorksheet(wb, swissfranc, sheet = &quot;CHF&quot;, startRow = 2, startCol = 2) # Save workbook - this actually writes the file saveWorkbook(wb) The steps above can be executed in a single call using the writeWorksheetToFile() function. # Write and save a data frame into a specific sheet of a workbook writeWorksheetToFile(&quot;xlconnect-demo/XLConnectDemo.xlsx&quot;, data = swissfranc, sheet = &quot;OneCall&quot;, startRow = 2, startCol = 2) The data frame can also be written in a named region using the single call writeNamedRegionToFile() function. This will create the sheet (if necessary) and named region name based on the formula argument and call writeNamedRegion instead of writeWorksheet. # Write and save a data frame into a specific named region of a workbook writeNamedRegionToFile(&quot;xlconnect-demo/XLConnectDemo.xlsx&quot;, data = swissfranc, name = &quot;SwissFrancName&quot;, formula = &quot;NamedRegionEx!$B$2&quot;) 5.2.2 Reading from Excel files # Read data from a specific sheet of a workbook dataFromExcel &lt;- readWorksheet(wb, sheet = &quot;CHF&quot;) # Read data from a specific location in a sheet of a workbook dataFromExcel &lt;- readWorksheet(wb, sheet = &quot;CHF&quot;, startRow = 2, endRow = 10, startCol = 2, endCol = 5, header = TRUE) The steps above can be executed in a single call using the readWorksheetFromFile() function. # Read data from a specific location in a sheet of a workbook dataFromExcel &lt;- readWorksheetFromFile(&quot;xlconnect-demo/XLConnectDemo.xlsx&quot;, sheet = &quot;OneCall&quot;, startRow = 2, endRow = 10, startCol = 2, endCol = 5, header = TRUE) The data can also be read from an existing named region using the single call readNamedRegionFromFile() function. # Read data from a specific named region of a workbook dataFromExcel &lt;- readNamedRegionFromFile(&quot;xlconnect-demo/XLConnectDemo.xlsx&quot;, name = &quot;SwissFrancName&quot;, header = TRUE) It can be useful to retrieve all the sheets of a workbook or all existing named regions. # Get all sheet names of a workbook allSheets &lt;- getSheets(wb) # Get all named regions of a workbook allnr &lt;- getDefinedNames(wb) "],["formatting.html", "5.3 Formatting", " 5.3 Formatting 5.3.1 Create and apply some formatting Now let’s try out some formatting functionality. # Apply data format only - depending on the data type setStyleAction(wb, XLC$STYLE_ACTION.DATA_FORMAT_ONLY) # Set format for numeric data to 2 decimal digits setDataFormatForType(wb, type = XLC$DATA_TYPE.NUMERIC, format = &quot;0.00&quot;) # Write the named region writeNamedRegion(wb, data = swissfranc, name = &quot;SwissFrancName&quot;) # Create a cell style for the headers csHeader &lt;- createCellStyle(wb, name = &quot;StyleHeader&quot;) setFillPattern(csHeader, fill = XLC$FILL.SOLID_FOREGROUND) setFillForegroundColor(csHeader, color = XLC$COLOR.CORNFLOWER_BLUE) setCellStyle(wb, sheet = &quot;NamedRegionEx&quot;, row = 2, col = seq(2, ncol(swissfranc) + 1), cellstyle = csHeader) # Set an auto-filter setAutoFilter(wb, sheet = &quot;NamedRegionEx&quot;, reference = aref(&quot;B2&quot;, dim(swissfranc))) # Create a custom format for the date column csDate &lt;- createCellStyle(wb, name = &quot;StyleDate&quot;) setDataFormat(csDate, format = &quot;yyyy-mm-dd&quot;) setCellStyle(wb, sheet = &quot;NamedRegionEx&quot;, row = seq(3, nrow(swissfranc) + 2), col = 2, cellstyle = csDate) # Enlarge column &quot;date&quot; to fit full information setColumnWidth(wb, sheet = &quot;NamedRegionEx&quot;, column = 2, width = 2800) # Save workbook - this actually writes the file saveWorkbook(wb) 5.3.2 Retrieve and apply some formatting Intermediate step to make a copy of the template. # Create a copy of the template file.copy(&quot;xlconnect-demo/XLConnectDemo-Tpl.xlsx&quot;, &quot;xlconnect-demo/XLCDemo-TplCopy.xlsx&quot;, overwrite = FALSE) wbcopy &lt;- loadWorkbook(&quot;xlconnect-demo/XLCDemo-TplCopy.xlsx&quot;) # Save workbook - this actually writes the file saveWorkbook(wbcopy) Add a new sheet in the copied file and use defined formatting from the template. # Create a dummy input sheet writeWorksheetToFile(&quot;xlconnect-demo/XLCDemo-TplCopy.xlsx&quot;, data = data.frame(&quot;Titles&quot; = c(&quot;Dummy Input&quot;, &quot;Exchange Rate CHF/Curr&quot;)), sheet = &quot;Input&quot;, startRow = 2, startCol = 2, header = FALSE) # Get some data from the previous file # Read data from a specific named region of a workbook if (exists(&quot;xlconnect-demo/XLConnectDemo.xlsx&quot;)) { dataToReuse &lt;- readNamedRegionFromFile(&quot;xlconnect-demo/XLConnectDemo.xlsx&quot;, name = &quot;SwissFrancName&quot;, header = TRUE) } else { dataToReuse &lt;- swissfranc } # Add data in a named region writeNamedRegionToFile(&quot;xlconnect-demo/XLCDemo-TplCopy.xlsx&quot;, data = dataToReuse, name = &quot;SwissFrancName&quot;, formula = &quot;Input!$B$5&quot;) # Retrieve formatting from existing cell style names from the template copy wbcopy &lt;- loadWorkbook(&quot;xlconnect-demo/XLCDemo-TplCopy.xlsx&quot;) cstitle1 &lt;- getCellStyle(wbcopy, &quot;Title1&quot;) cstitle2 &lt;- getCellStyle(wbcopy, &quot;Title2&quot;) csTableHeader &lt;- getCellStyle(wbcopy, &quot;TableHeader&quot;) csinp &lt;- getCellStyle(wbcopy, &quot;Inp&quot;) cscalc &lt;- getCellStyle(wbcopy, &quot;Calc&quot;) # Apply formatting - this has to be in the same file setCellStyle(wbcopy, formula = &quot;Input!$B$2:$B$2&quot;, cellstyle = cstitle1) setCellStyle(wbcopy, formula = &quot;Input!$B$3:$B$3&quot;, cellstyle = cstitle2) setCellStyle(wbcopy, formula = &quot;Input!$C$5:$E$425&quot;, cellstyle = csinp) setCellStyle(wbcopy, formula = &quot;Input!$B$5:$B$425&quot;, cellstyle = cscalc) if (!existsCellStyle(wbcopy, &quot;csDate&quot;)) { csDate &lt;- createCellStyle(wbcopy, name = &quot;DateFormat&quot;) setDataFormat(csDate, format = &quot;yyyy-mm-dd&quot;) } setCellStyle(wbcopy, sheet = &quot;Input&quot;, row = 5:425, col = 2, cellstyle = csDate) # Save workbook - this actually writes the file saveWorkbook(wbcopy) "],["add-a-graph.html", "5.4 Add a graph", " 5.4 Add a graph First, create an image out of a graph. # Prepare object currencies &lt;- names(swissfranc)[-1] gcurr &lt;- reshape(swissfranc, varying = currencies, direction = &quot;long&quot;, v.names = &quot;Value&quot;, times = currencies, timevar = &quot;Currency&quot;) # Use ggplot2 to create a graph require(ggplot2) p &lt;- ggplot(gcurr, aes(Date, Value, colour = Currency)) + geom_line() + stat_smooth(method = &quot;loess&quot;) + scale_y_continuous(&quot;Exchange Rate CHF/Curr&quot;) + labs(title = paste0(&quot;CHF vs &quot;, paste(currencies, collapse = &quot;, &quot;)), x = &quot;&quot;) + theme(axis.title.y = element_text(size = 10, angle = 90, vjust = 0.3)) print(p) # Save plot to as a png dev.copy(png, &quot;xlconnect-demo/swissfrancplot.png&quot;) dev.off() Then, add the image to the output file. # Define the location in the output file createName(wb, name = &quot;graph&quot;, formula = &quot;NamedRegionEx!$H$2&quot;) # Add image to the file addImage(wb, filename = &quot;xlconnect-demo/swissfrancplot.png&quot;, name = &quot;graph&quot;, originalSize = TRUE) # Save workbook - this actually writes the file saveWorkbook(wb) "],["other-functionalities.html", "5.5 Other functionalities", " 5.5 Other functionalities Let’s perform some usual tasks on a template and use few more interesting XLConnect functionalities like: ensure values get updated when opening a workbook check if a sheet is visible check if a named region exists hide or unhide sheets append a named region get the coordinates of a named region in a sheet additional formatting, e.g. setting the column width remove sheets and named regions clone a sheet add a hyperlink 5.5.1 Recalculate workbook Read the file and update some values on the R objects. if (!exists(&quot;xlconnect-demo/XLCDemo-TplCopy.xlsx&quot;)) { # Create a copy of the template file.copy(&quot;xlconnect-demo/XLConnectDemo-Tpl.xlsx&quot;, &quot;xlconnect-demo/XLCDemo-TplCopy.xlsx&quot;, overwrite = FALSE) } # Load copy of the template wbcopy &lt;- loadWorkbook(&quot;xlconnect-demo/XLCDemo-TplCopy.xlsx&quot;) # Read data from template copy using named regions inc_df &lt;- readNamedRegion(wbcopy, name = &quot;Income_inp&quot;, header = TRUE) persexp_df &lt;- readNamedRegion(wbcopy, name = &quot;PersExpenses_inp&quot;, header = TRUE) opexp_df &lt;- readNamedRegion(wbcopy, name = &quot;OpExpenses_inp&quot;, header = TRUE) # Update numbers: double sales inc_df$ACTUAL[inc_df$INCOME == &quot;Net sales&quot;] &lt;- inc_df$ACTUAL[inc_df$INCOME == &quot;Net sales&quot;] * 2 # Update numbers: add employee benefits persexp_df$ACTUAL[persexp_df$PERSONNEL.EXPENSES == &quot;Employee benefits&quot;] &lt;- 3000 # Update numbers: reduce maintenance opexp_df$ACTUAL[opexp_df$OPERATING.EXPENSES == &quot;Maintenance and repairs&quot;] &lt;- 2500 Write the data into the workbook, set the “force formula recalculation” flag on it and save the file. # Update output accordingly writeNamedRegion(wbcopy, Sys.Date(), &quot;Date&quot;, header = FALSE) writeNamedRegion(wbcopy, inc_df, &quot;Income_out&quot;, header = FALSE) writeNamedRegion(wbcopy, persexp_df, &quot;PersExpenses_out&quot;, header = FALSE) writeNamedRegion(wbcopy, opexp_df, &quot;OpExpenses_out&quot;, header = FALSE) # Get numbers of sheets nb_sheets &lt;- length(getSheets(wbcopy)) # Force Excel to re-calculate when opening the workbook setForceFormulaRecalculation(wbcopy, sheet = seq(1, nb_sheets), TRUE) # Save workbook - this actually writes the file saveWorkbook(wbcopy) 5.5.2 Hide sheets Hide irrelevant sheets. # Hide sheets sheetsToHide &lt;- c(&quot;Style&quot;, &quot;Input&quot;) # Ensure those sheets exist in the workbook sheetsToHide &lt;- sheetsToHide[sheetsToHide %in% getSheets(wbcopy)] hideSheet(wbcopy, sheetsToHide, veryHidden = TRUE) # Save workbook - this actually writes the file saveWorkbook(wbcopy) 5.5.3 Sheet visibility check and unhide sheets Check if a given sheet is visible and unhide it if it is. # Check if a sheet is visible and unhide it if (!isSheetVisible(wbcopy, c(&quot;Review&quot;))) { # Unhide sheet unhideSheet(wbcopy, &quot;Review&quot;) } # Save workbook - this actually writes the file saveWorkbook(wbcopy) 5.5.4 Append named region Check if a named region exists and append it if it does. # Check if a named region exists if (existsName(wbcopy, c(&quot;Review&quot;))) { # Create a new entry to append newreview_df &lt;- data.frame(Reviewer = c(&quot;Sam Tire&quot;), Function = c(&quot;Accounting Reviewer&quot;), Date = Sys.Date()) # Ensure column matches if (!all(colnames(newreview_df) == colnames(readNamedRegion(wbcopy, &quot;Review&quot;)))) { stop(&quot;table to populate does not match expected header, column names and order must match&quot;) } # Append existing named region appendNamedRegion(wbcopy, newreview_df, name = &quot;Review&quot;) csinp &lt;- getCellStyle(wbcopy, &quot;Inp&quot;) # Get position of a named region in a Excel file review_pos &lt;- getReferenceCoordinatesForName(wbcopy, &quot;Review&quot;) colStart_pos &lt;- LETTERS[review_pos[1,2]] colEnd_pos &lt;- LETTERS[review_pos[2,2]] # Apply cell formatting setCellStyle(wbcopy, formula = paste0(&quot;Review!&quot;, colStart_pos, &quot;$&quot;, review_pos[1,1] + 1, &quot;:$&quot;, colEnd_pos, review_pos[2,1]), cellstyle = csinp) if (!existsCellStyle(wbcopy, &quot;Format-Date&quot;)) { # Create a custom format for the date column csDate &lt;- createCellStyle(wbcopy, name = &quot;Format-Date&quot;) setDataFormat(csDate, format = &quot;yyyy-mm-dd&quot;) } setCellStyle(wbcopy, sheet = &quot;Review&quot;, row = seq(review_pos[1,1] + 1, review_pos[2,1]), col = review_pos[2,2], cellstyle = csDate) # Enlarge column date setColumnWidth(wbcopy, sheet = &quot;Review&quot;, column = review_pos[2,2], width = 4000 ) # Save workbook - this actually writes the file saveWorkbook(wbcopy) } 5.5.5 Remove sheets Delete sheets. # Create a new copy file.copy(&quot;xlconnect-demo/XLCDemo-TplCopy.xlsx&quot;, &quot;xlconnect-demo/XLCDemo-Input.xlsx&quot;, overwrite = FALSE) # Load new copy wbinput &lt;- loadWorkbook(&quot;xlconnect-demo/XLCDemo-Input.xlsx&quot;) # Unhide sheet - if goal is to remove all sheets but &quot;input&quot; then it has to be visible unhideSheet(wbinput, &quot;Input&quot;) # Remove all sheets of the copy but &quot;input&quot; wbinput_allsheets &lt;- getSheets(wbinput) removeSheet(wbinput, wbinput_allsheets[!(wbinput_allsheets %in% c(&quot;Input&quot;))]) # Save workbook - this actually writes the file saveWorkbook(wbinput) 5.5.6 Remove named regions Delete Named Regions. # Load new copy wbinput &lt;- loadWorkbook(&quot;xlconnect-demo/XLCDemo-Input.xlsx&quot;) # Remove all named regions of the copy but &quot;SwissFrancName&quot; wbinput_allnr &lt;- getDefinedNames(wbinput) removeName(wbinput, wbinput_allnr[!(wbinput_allnr %in% c(&quot;SwissFrancName&quot;))]) # Save workbook - this actually writes the file saveWorkbook(wbinput) 5.5.7 Clone sheets Clone a sheet. # Load new copy wbinput &lt;- loadWorkbook(&quot;xlconnect-demo/XLCDemo-Input.xlsx&quot;) # Ensure sheet exists if (existsSheet(wbinput, &quot;Input&quot;)) { # Clone sheet cloneSheet(wbinput, sheet = &quot;Input&quot;, name = &quot;clonedSheet&quot;) # Save workbook - this actually writes the file saveWorkbook(wbinput) } 5.5.8 Clear sheets Clear a sheet can be useful if data sets in a worksheet need to be replaced in a smaller range as the original data. # Load new copy wbinput &lt;- loadWorkbook(&quot;xlconnect-demo/XLCDemo-Input.xlsx&quot;) if (existsSheet(wbinput, &quot;clonedSheet&quot;)) { # Clear sheet clearSheet(wbinput, sheet = &quot;clonedSheet&quot;) # Save workbook - this actually writes the file saveWorkbook(wbinput) } 5.5.9 Add hyperlinks Write a hyperlink. # Load new copy wbinput &lt;- loadWorkbook(&quot;xlconnect-demo/XLCDemo-Input.xlsx&quot;) if (existsSheet(wbinput, &quot;clonedSheet&quot;)) { # Add hyperlink writeWorksheet(wbinput, data.frame(Company = &quot;Mirai Solution&quot;), sheet = &quot;clonedSheet&quot;, startRow = 1, startCol = 2) mirai_web &lt;- &quot;https://mirai-solutions.ch/&quot; setHyperlink(wbinput, sheet = &quot;clonedsheet&quot;, row = 2, col = 2, type = XLC$HYPERLINK.URL, address = mirai_web) # Save workbook - this actually writes the file saveWorkbook(wbinput) } 5.5.10 Merge / Unmerge cells Merge or unmerge cells. # Load new copy wbinput &lt;- loadWorkbook(&quot;xlconnect-demo/XLCDemo-Input.xlsx&quot;) if (existsSheet(wbinput, &quot;clonedSheet&quot;)) { # Merge cells - to unmerge, use the similar function &#39;unmergeCells()&#39; mergeCells(wbinput, sheet = &quot;clonedsheet&quot;, reference = &quot;B2:C2&quot;) # Save workbook - this actually writes the file saveWorkbook(wbinput) } 5.5.11 Clean up Clean up and remove the demo files. # Remove file file.remove(&quot;xlconnect-demo/XLConnectDemo.xlsx&quot;) file.remove(&quot;xlconnect-demo/XLCDemo-TplCopy.xlsx&quot;) file.remove(&quot;xlconnect-demo/XLCDemo-Input.xlsx&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
